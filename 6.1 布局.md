# Layout

é‚£ä¹ˆå•é“¾è¡¨é˜Ÿåˆ—æ˜¯ä»€ä¹ˆæ ·å­çš„å‘¢ï¼Ÿå¥½å§æˆ‘ä»¬å·²æœ‰ä¸€ä¸ªå•é“¾æ ˆï¼Œæˆ‘ä»¬Pushåˆ°é“¾è¡¨çš„ä¸€ç«¯ï¼Œç„¶åä»åŒä¸€ç«¯Popå‡ºæ¥ã€‚æ ˆå’Œé˜Ÿåˆ—ä¹‹é—´çš„å”¯ä¸€åŒºåˆ«æ˜¯é˜Ÿåˆ—ä»*å¦ä¸€ç«¯*å¼¹å‡ºã€‚å› æ­¤ä»æˆ‘ä»¬çš„å †æ ˆå®ç°æ¥çœ‹ï¼š

```text
input list:
[Some(ptr)] -> (A, Some(ptr)) -> (B, None)

stack push X:
[Some(ptr)] -> (X, Some(ptr)) -> (A, Some(ptr)) -> (B, None)

stack pop:
[Some(ptr)] -> (A, Some(ptr)) -> (B, None)
```

è¦ç”Ÿæˆé˜Ÿåˆ—ï¼Œæˆ‘ä»¬åªéœ€è¦å†³å®šå°†å“ªä¸ªæ“ä½œç§»åŠ¨åˆ°åˆ—è¡¨çš„æœ«å°¾ï¼Œpushè¿˜æ˜¯popï¼Ÿå› ä¸ºæˆ‘ä»¬çš„é“¾è¡¨æ˜¯å•é“¾çš„ï¼Œå¯ä»¥å°†ä»»æ„ä¸€ä¸ªæ“ä½œæ”¾ç½®å°¾éƒ¨ã€‚

å¦‚æœå°†pushæ”¾åœ¨å°¾éƒ¨ï¼Œæˆ‘ä»¬åªéœ€ä»å¤´éƒ¨å¼€å§‹èµ°åˆ°Noneå…ƒç´ ï¼Œç„¶åè®¾ç½®æ–°å…ƒç´ ã€‚

```text
input list:
[Some(ptr)] -> (A, Some(ptr)) -> (B, None)

flipped push X:
[Some(ptr)] -> (A, Some(ptr)) -> (B, Some(ptr)) -> (X, None)
```

å¦‚æœå°†popæ”¾åœ¨å°¾éƒ¨ï¼Œæˆ‘ä»¬åªéœ€è¦èµ°åˆ°Nodeçš„å‰é¢èŠ‚ç‚¹ï¼Œç„¶åå–å‡ºï¼š

```text
input list:
[Some(ptr)] -> (A, Some(ptr)) -> (B, Some(ptr)) -> (X, None)

flipped pop:
[Some(ptr)] -> (A, Some(ptr)) -> (B, None)
```

æˆ‘ä»¬å¯ä»¥ä»Šå¤©å°±è¿™ä¹ˆåšç„¶åå°±æ­¤ç½¢ä¼‘ï¼Œä½†é‚£å¤ªç³Ÿç³•äº†ï¼è¿™ä¸¤ä¸ªæ“ä½œäººéƒ½éœ€è¦éå†æ•´ä¸ªåˆ—è¡¨ã€‚æœ‰äº›äººè®¤ä¸ºè¿™æ ·çš„é˜Ÿåˆ—å®ç°ç¡®å®æ˜¯ä¸€ä¸ªé˜Ÿåˆ—ï¼Œå› ä¸ºå®ƒå…¬å¼€äº†æ­£ç¡®çš„æ¥å£ã€‚ä½†æ˜¯æˆ‘ç›¸ä¿¡æ€§èƒ½ä¿è¯æ˜¯æ¥å£çš„ä¸€éƒ¨åˆ†ã€‚æˆ‘ä¸å…³å¿ƒç²¾ç¡®è¾¹ç•Œï¼Œåªæ˜¯å¿«å’Œæ…¢ã€‚é˜Ÿåˆ—ä¿è¯äº†pushå’Œpopçš„é€Ÿåº¦å¾ˆå¿«ï¼Œè€Œéå†æ•´ä¸ªåˆ—è¡¨è‚¯å®šä¸æ˜¯å¾ˆå¿«ã€‚

ä¸€ä¸ªå…³é”®çš„ç»“è®ºæ˜¯ï¼Œæˆ‘ä»¬ä¸€æ¬¡åˆä¸€æ¬¡åœ°åšåŒæ ·çš„äº‹æƒ…ï¼Œæµªè´¹äº†å¤§é‡çš„å·¥ä½œã€‚æˆ‘ä»¬èƒ½è®°å¿†è¿™ä¸ªå·¥ä½œå—ï¼Ÿä¸ºä»€ä¹ˆï¼Œæ˜¯çš„ï¼æˆ‘ä»¬å¯ä»¥å­˜å‚¨ä¸€ä¸ªæŒ‡å‘åˆ—è¡¨æœ«å°¾çš„æŒ‡é’ˆï¼Œç„¶åç›´æ¥è·³åˆ°é‚£é‡Œï¼

äº‹å®è¯æ˜ï¼Œéœ€è¦å€’è¿‡æ¥ä¸€ä¸ªâ€œpushâ€æˆ–â€œpopâ€ä¸æ­¤é…åˆä½¿ç”¨ï¼Œè¦åè½¬popï¼Œæˆ‘ä»¬å¿…é¡»åå‘ç§»åŠ¨`tail`æŒ‡é’ˆï¼Œå› ä¸ºé“¾è¡¨æ˜¯å•é“¾çš„ï¼Œæˆ‘ä»¬ä¸èƒ½æœ‰æ•ˆçš„å®ç°ï¼Œç›¸åå¦‚æœæˆ‘ä»¬åè½¬`push`ï¼Œæˆ‘ä»¬åªéœ€è¦æ­£å‘ç§»åŠ¨headæŒ‡é’ˆã€‚è¿™å¾ˆå®¹æ˜“

æˆ‘ä»¬è¯•è¯•ï¼š

```rust ,ignore
use std::mem;

pub struct List<T> {
    head: Link<T>,
    tail: Link<T>, // NEW!
}

type Link<T> = Option<Box<Node<T>>>;

struct Node<T> {
    elem: T,
    next: Link<T>,
}

impl<T> List<T> {
    pub fn new() -> Self {
        List { head: None, tail: None }
    }

    pub fn push(&mut self, elem: T) {
        let new_tail = Box::new(Node {
            elem: elem,
            // When you push onto the tail, your next is always None
            next: None,
        });

        // swap the old tail to point to the new tail
        let old_tail = mem::replace(&mut self.tail, Some(new_tail));

        match old_tail {
            Some(mut old_tail) => {
                // If the old tail existed, update it to point to the new tail
                old_tail.next = Some(new_tail);
            }
            None => {
                // Otherwise, update the head to point to it
                self.head = Some(new_tail);
            }
        }
    }
}
```

I'm going a bit faster with the impl details now since we should be pretty
comfortable with this sort of thing. Not that you should necessarily expect
to produce this code on the first try. I'm just skipping over some of the
trial-and-error we've had to deal with before. I actually made a ton of mistakes
writing this code that I'm not showing. You can only see me leave off a `mut` or
`;` so many times before it stops being instructive. Don't worry, we'll see
plenty of *other* error messages!

```text
> cargo build

error[E0382]: use of moved value: `new_tail`
  --> src/fifth.rs:38:38
   |
26 |         let new_tail = Box::new(Node {
   |             -------- move occurs because `new_tail` has type `std::boxed::Box<fifth::Node<T>>`, which does not implement the `Copy` trait
...
33 |         let old_tail = mem::replace(&mut self.tail, Some(new_tail));
   |                                                          -------- value moved here
...
38 |                 old_tail.next = Some(new_tail);
   |                                      ^^^^^^^^ value used here after move
```

Shoot!

> use of moved value: `new_tail`

Box doesn't implement Copy, so we can't just assign it to two locations. More
importantly, Box *owns* the thing it points to, and will try to free it when
it's dropped. If our `push` implementation compiled, we'd double-free the tail
of our list! Actually, as written, our code would free the old_tail on every
push. Yikes! ğŸ™€

Alright, well we know how to make a non-owning pointer. That's just a reference!

```rust ,ignore
pub struct List<T> {
    head: Link<T>,
    tail: Option<&mut Node<T>>, // NEW!
}

type Link<T> = Option<Box<Node<T>>>;

struct Node<T> {
    elem: T,
    next: Link<T>,
}

impl<T> List<T> {
    pub fn new() -> Self {
        List { head: None, tail: None }
    }

    pub fn push(&mut self, elem: T) {
        let new_tail = Box::new(Node {
            elem: elem,
            // When you push onto the tail, your next is always None
            next: None,
        });

        // Put the box in the right place, and then grab a reference to its Node
        let new_tail = match self.tail.take() {
            Some(old_tail) => {
                // If the old tail existed, update it to point to the new tail
                old_tail.next = Some(new_tail);
                old_tail.next.as_deref_mut()
            }
            None => {
                // Otherwise, update the head to point to it
                self.head = Some(new_tail);
                self.head.as_deref_mut()
            }
        };

        self.tail = new_tail;
    }
}
```

Nothing too tricky here. Same basic idea as the previous code, except we're
using some of that implicit return goodness to extract the tail reference from
wherever we stuff the actual Box.

```text
> cargo build

error[E0106]: missing lifetime specifier
 --> src/fifth.rs:3:18
  |
3 |     tail: Option<&mut Node<T>>, // NEW!
  |                  ^ expected lifetime parameter
```

Oh right, we need to give references in types lifetimes. Hmm... what's the
lifetime of this reference? Well, this seems like IterMut, right? Let's try
what we did for IterMut, and just add a generic `'a`:

```rust ,ignore
pub struct List<'a, T> {
    head: Link<T>,
    tail: Option<&'a mut Node<T>>, // NEW!
}

type Link<T> = Option<Box<Node<T>>>;

struct Node<T> {
    elem: T,
    next: Link<T>,
}

impl<'a, T> List<'a, T> {
    pub fn new() -> Self {
        List { head: None, tail: None }
    }

    pub fn push(&mut self, elem: T) {
        let new_tail = Box::new(Node {
            elem: elem,
            // When you push onto the tail, your next is always None
            next: None,
        });

        // Put the box in the right place, and then grab a reference to its Node
        let new_tail = match self.tail.take() {
            Some(old_tail) => {
                // If the old tail existed, update it to point to the new tail
                old_tail.next = Some(new_tail);
                old_tail.next.as_deref_mut()
            }
            None => {
                // Otherwise, update the head to point to it
                self.head = Some(new_tail);
                self.head.as_deref_mut()
            }
        };

        self.tail = new_tail;
    }
}
```

```text
cargo build

error[E0495]: cannot infer an appropriate lifetime for autoref due to conflicting requirements
  --> src/fifth.rs:35:27
   |
35 |                 self.head.as_deref_mut()
   |                           ^^^^^^^^^^^^
   |
note: first, the lifetime cannot outlive the anonymous lifetime #1 defined on the method body at 18:5...
  --> src/fifth.rs:18:5
   |
18 | /     pub fn push(&mut self, elem: T) {
19 | |         let new_tail = Box::new(Node {
20 | |             elem: elem,
21 | |             // When you push onto the tail, your next is always None
...  |
39 | |         self.tail = new_tail;
40 | |     }
   | |_____^
note: ...so that reference does not outlive borrowed content
  --> src/fifth.rs:35:17
   |
35 |                 self.head.as_deref_mut()
   |                 ^^^^^^^^^
note: but, the lifetime must be valid for the lifetime 'a as defined on the impl at 13:6...
  --> src/fifth.rs:13:6
   |
13 | impl<'a, T> List<'a, T> {
   |      ^^
   = note: ...so that the expression is assignable:
           expected std::option::Option<&'a mut fifth::Node<T>>
              found std::option::Option<&mut fifth::Node<T>>


```

Woah, that's a really detailed error message. That's a bit concerning, because it
suggests we're doing something really messed up. Here's an interesting part:

> the lifetime must be valid for the lifetime `'a` as defined on the impl

We're borrowing from `self`, but the compiler wants us to last as long as `'a`,
what if we tell it `self` *does* last that long..?

```rust ,ignore
    pub fn push(&'a mut self, elem: T) {
```

```text
cargo build

warning: field is never used: `elem`
 --> src/fifth.rs:9:5
  |
9 |     elem: T,
  |     ^^^^^^^
  |
  = note: #[warn(dead_code)] on by default
```

Oh, hey, that worked! Great!

Let's just do `pop` too:

```rust ,ignore
pub fn pop(&'a mut self) -> Option<T> {
    // Grab the list's current head
    self.head.take().map(|head| {
        let head = *head;
        self.head = head.next;

        // If we're out of `head`, make sure to set the tail to `None`.
        if self.head.is_none() {
            self.tail = None;
        }

        head.elem
    })
}
```

And write a quick test for that:

```rust ,ignore
mod test {
    use super::List;
    #[test]
    fn basics() {
        let mut list = List::new();

        // Check empty list behaves right
        assert_eq!(list.pop(), None);

        // Populate list
        list.push(1);
        list.push(2);
        list.push(3);

        // Check normal removal
        assert_eq!(list.pop(), Some(1));
        assert_eq!(list.pop(), Some(2));

        // Push some more just to make sure nothing's corrupted
        list.push(4);
        list.push(5);

        // Check normal removal
        assert_eq!(list.pop(), Some(3));
        assert_eq!(list.pop(), Some(4));

        // Check exhaustion
        assert_eq!(list.pop(), Some(5));
        assert_eq!(list.pop(), None);
    }
}
```

```text
cargo test

error[E0499]: cannot borrow `list` as mutable more than once at a time
  --> src/fifth.rs:68:9
   |
65 |         assert_eq!(list.pop(), None);
   |                    ---- first mutable borrow occurs here
...
68 |         list.push(1);
   |         ^^^^
   |         |
   |         second mutable borrow occurs here
   |         first borrow later used here

error[E0499]: cannot borrow `list` as mutable more than once at a time
  --> src/fifth.rs:69:9
   |
65 |         assert_eq!(list.pop(), None);
   |                    ---- first mutable borrow occurs here
...
69 |         list.push(2);
   |         ^^^^
   |         |
   |         second mutable borrow occurs here
   |         first borrow later used here

error[E0499]: cannot borrow `list` as mutable more than once at a time
  --> src/fifth.rs:70:9
   |
65 |         assert_eq!(list.pop(), None);
   |                    ---- first mutable borrow occurs here
...
70 |         list.push(3);
   |         ^^^^
   |         |
   |         second mutable borrow occurs here
   |         first borrow later used here


....

** WAY MORE LINES OF ERRORS **

....

error: aborting due to 11 previous errors
```

ğŸ™€ğŸ™€ğŸ™€ğŸ™€ğŸ™€ğŸ™€ğŸ™€ğŸ™€ğŸ™€ğŸ™€ğŸ™€ğŸ™€ğŸ™€ğŸ™€ğŸ™€ğŸ™€ğŸ™€ğŸ™€ğŸ™€ğŸ™€ğŸ™€ğŸ™€ğŸ™€

Oh my goodness.

The compiler's not wrong for vomiting all over us. We just committed a
cardinal Rust sin: we stored a reference to ourselves *inside ourselves*.
Somehow, we managed to convince Rust that this totally made sense in our
`push` and `pop` implementations (I was legitimately shocked we did). I believe
the reason is that Rust can't yet tell that the reference is into ourselves
from just `push` and `pop` -- or rather, Rust doesn't really have that notion
at all. Reference-into-yourself failing to work is just an emergent behaviour.

As soon as we tried to *use* our list, everything quickly fell apart.
When we call `push` or `pop`, we promptly store a reference to ourselves in
ourselves and become *trapped*. We are literally borrowing ourselves.

Our `pop` implementation hints at why this could be really dangerous:

```rust ,ignore
// ...
if self.head.is_none() {
    self.tail = None;
}
```

What if we forgot to do this? Then our tail would point to some node *that
had been removed from the list*. Such a node would be instantly freed, and we'd
have a dangling pointer which Rust was supposed to protect us from!

And indeed Rust is protecting us from that kind of danger. Just in a very...
**roundabout** way.

So what can we do? Go back to `Rc<RefCell>>` hell?

Please. No.

No instead we're going to go off the rails and use *raw pointers*.
Our layout is going to look like this:

```rust ,ignore
pub struct List<T> {
    head: Link<T>,
    tail: *mut Node<T>, // DANGER DANGER
}

type Link<T> = Option<Box<Node<T>>>;

struct Node<T> {
    elem: T,
    next: Link<T>,
}
```

And that's that. None of this wimpy reference-counted-dynamic-borrow-checking
nonsense! Real. Hard. Unchecked. Pointers.

Let's be C everyone. Let's be C all day.

I'm home. I'm ready.

Hello `unsafe`.