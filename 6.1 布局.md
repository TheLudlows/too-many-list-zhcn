# Layout

é‚£ä¹ˆå•é“¾è¡¨é˜Ÿåˆ—æ˜¯ä»€ä¹ˆæ ·å­çš„å‘¢ï¼Ÿå¥½å§æˆ‘ä»¬å·²æœ‰ä¸€ä¸ªå•é“¾æ ˆï¼Œæˆ‘ä»¬Pushåˆ°é“¾è¡¨çš„ä¸€ç«¯ï¼Œç„¶åä»åŒä¸€ç«¯Popå‡ºæ¥ã€‚æ ˆå’Œé˜Ÿåˆ—ä¹‹é—´çš„å”¯ä¸€åŒºåˆ«æ˜¯é˜Ÿåˆ—ä»*å¦ä¸€ç«¯*å¼¹å‡ºã€‚å› æ­¤ä»æˆ‘ä»¬çš„å †æ ˆå®ç°æ¥çœ‹ï¼š

```text
input list:
[Some(ptr)] -> (A, Some(ptr)) -> (B, None)

stack push X:
[Some(ptr)] -> (X, Some(ptr)) -> (A, Some(ptr)) -> (B, None)

stack pop:
[Some(ptr)] -> (A, Some(ptr)) -> (B, None)
```

è¦ç”Ÿæˆé˜Ÿåˆ—ï¼Œæˆ‘ä»¬åªéœ€è¦å†³å®šå°†å“ªä¸ªæ“ä½œç§»åŠ¨åˆ°åˆ—è¡¨çš„æœ«å°¾ï¼Œpushè¿˜æ˜¯popï¼Ÿå› ä¸ºæˆ‘ä»¬çš„é“¾è¡¨æ˜¯å•é“¾çš„ï¼Œå¯ä»¥å°†ä»»æ„ä¸€ä¸ªæ“ä½œæ”¾ç½®å°¾éƒ¨ã€‚

å¦‚æœå°†pushæ”¾åœ¨å°¾éƒ¨ï¼Œæˆ‘ä»¬åªéœ€ä»å¤´éƒ¨å¼€å§‹èµ°åˆ°Noneå…ƒç´ ï¼Œç„¶åè®¾ç½®æ–°å…ƒç´ ã€‚

```text
input list:
[Some(ptr)] -> (A, Some(ptr)) -> (B, None)

flipped push X:
[Some(ptr)] -> (A, Some(ptr)) -> (B, Some(ptr)) -> (X, None)
```

å¦‚æœå°†popæ”¾åœ¨å°¾éƒ¨ï¼Œæˆ‘ä»¬åªéœ€è¦èµ°åˆ°Nodeçš„å‰é¢èŠ‚ç‚¹ï¼Œç„¶åå–å‡ºï¼š

```text
input list:
[Some(ptr)] -> (A, Some(ptr)) -> (B, Some(ptr)) -> (X, None)

flipped pop:
[Some(ptr)] -> (A, Some(ptr)) -> (B, None)
```

æˆ‘ä»¬å¯ä»¥ä»Šå¤©å°±è¿™ä¹ˆåšç„¶åå°±æ­¤ç½¢ä¼‘ï¼Œä½†é‚£å¤ªç³Ÿç³•äº†ï¼è¿™ä¸¤ä¸ªæ“ä½œäººéƒ½éœ€è¦éå†æ•´ä¸ªåˆ—è¡¨ã€‚æœ‰äº›äººè®¤ä¸ºè¿™æ ·çš„é˜Ÿåˆ—å®ç°ç¡®å®æ˜¯ä¸€ä¸ªé˜Ÿåˆ—ï¼Œå› ä¸ºå®ƒå…¬å¼€äº†æ­£ç¡®çš„æ¥å£ã€‚ä½†æ˜¯æˆ‘ç›¸ä¿¡æ€§èƒ½ä¿è¯æ˜¯æ¥å£çš„ä¸€éƒ¨åˆ†ã€‚æˆ‘ä¸å…³å¿ƒç²¾ç¡®è¾¹ç•Œï¼Œåªæ˜¯å¿«å’Œæ…¢ã€‚é˜Ÿåˆ—ä¿è¯äº†pushå’Œpopçš„é€Ÿåº¦å¾ˆå¿«ï¼Œè€Œéå†æ•´ä¸ªåˆ—è¡¨è‚¯å®šä¸æ˜¯å¾ˆå¿«ã€‚

ä¸€ä¸ªå…³é”®çš„ç»“è®ºæ˜¯ï¼Œæˆ‘ä»¬ä¸€æ¬¡åˆä¸€æ¬¡åœ°åšåŒæ ·çš„äº‹æƒ…ï¼Œæµªè´¹äº†å¤§é‡çš„å·¥ä½œã€‚æˆ‘ä»¬èƒ½è®°å¿†è¿™ä¸ªå·¥ä½œå—ï¼Ÿä¸ºä»€ä¹ˆï¼Œæ˜¯çš„ï¼æˆ‘ä»¬å¯ä»¥å­˜å‚¨ä¸€ä¸ªæŒ‡å‘åˆ—è¡¨æœ«å°¾çš„æŒ‡é’ˆï¼Œç„¶åç›´æ¥è·³åˆ°é‚£é‡Œï¼

äº‹å®è¯æ˜ï¼Œéœ€è¦å€’è¿‡æ¥ä¸€ä¸ªâ€œpushâ€æˆ–â€œpopâ€ä¸æ­¤é…åˆä½¿ç”¨ï¼Œè¦åè½¬popï¼Œæˆ‘ä»¬å¿…é¡»åå‘ç§»åŠ¨`tail`æŒ‡é’ˆï¼Œå› ä¸ºé“¾è¡¨æ˜¯å•é“¾çš„ï¼Œæˆ‘ä»¬ä¸èƒ½æœ‰æ•ˆçš„å®ç°ï¼Œç›¸åå¦‚æœæˆ‘ä»¬åè½¬`push`ï¼Œæˆ‘ä»¬åªéœ€è¦æ­£å‘ç§»åŠ¨headæŒ‡é’ˆã€‚è¿™å¾ˆå®¹æ˜“

æˆ‘ä»¬è¯•è¯•ï¼š

```rust ,ignore
use std::mem;

pub struct List<T> {
    head: Link<T>,
    tail: Link<T>, // NEW!
}

type Link<T> = Option<Box<Node<T>>>;

struct Node<T> {
    elem: T,
    next: Link<T>,
}

impl<T> List<T> {
    pub fn new() -> Self {
        List { head: None, tail: None }
    }

    pub fn push(&mut self, elem: T) {
        let new_tail = Box::new(Node {
            elem: elem,
            // When you push onto the tail, your next is always None
            next: None,
        });

        // swap the old tail to point to the new tail
        let old_tail = mem::replace(&mut self.tail, Some(new_tail));

        match old_tail {
            Some(mut old_tail) => {
                // If the old tail existed, update it to point to the new tail
                old_tail.next = Some(new_tail);
            }
            None => {
                // Otherwise, update the head to point to it
                self.head = Some(new_tail);
            }
        }
    }
}
```

æˆ‘ç°åœ¨è¦åŠ å¿«ä¸€äº›implçš„ç»†èŠ‚ï¼Œå› ä¸ºæˆ‘ä»¬åº”è¯¥å¯¹è¿™ç±»äº‹æƒ…å¾ˆèˆ’æœäº†ã€‚å¹¶éä¸€å®šè¦åœ¨ç¬¬ä¸€æ¬¡å°è¯•æ—¶å°±å†™å‡ºæ­¤ä»£ç ã€‚æˆ‘åªæ˜¯ç•¥è¿‡ä¸€äº›æˆ‘ä»¬ä»¥å‰å¿…é¡»é¢å¯¹çš„è¯•é”™ã€‚å®é™…ä¸Šï¼Œæˆ‘åœ¨ç¼–å†™è¿™ä¸ªä»£ç æ—¶çŠ¯äº†å¾ˆå¤šé”™è¯¯ï¼Œæˆ‘æ²¡æœ‰å±•ç¤ºè¿™äº›ä»£ç ã€‚ä½ åªèƒ½çœ‹åˆ°æˆ‘å¤šæ¬¡çœç•¥ä¸€ä¸ª`mut`æˆ–`ï¼›`ï¼Œç„¶åå®ƒå°±ä¸å†æœ‰æ•™è‚²æ„ä¹‰äº†ã€‚åˆ«æ‹…å¿ƒï¼Œæˆ‘ä»¬ä¼šçœ‹åˆ°å¾ˆå¤šå…¶ä»–çš„é”™è¯¯ä¿¡æ¯ï¼

```text
> cargo build

error[E0382]: use of moved value: `new_tail`
  --> src/fifth.rs:38:38
   |
26 |         let new_tail = Box::new(Node {
   |             -------- move occurs because `new_tail` has type `std::boxed::Box<fifth::Node<T>>`, which does not implement the `Copy` trait
...
33 |         let old_tail = mem::replace(&mut self.tail, Some(new_tail));
   |                                                          -------- value moved here
...
38 |                 old_tail.next = Some(new_tail);
   |                                      ^^^^^^^^ value used here after move
```

Shoot!

> use of moved value: `new_tail`

Boxæ²¡å®ç°`Copy`ï¼Œæ‰€ä»¥æˆ‘ä»¬ä¸èƒ½åªå°†å®ƒåˆ†é…åˆ°ä¸¤ä¸ªä½ç½®ã€‚æ›´é‡è¦çš„æ˜¯ï¼ŒBoxæ‹¥æœ‰å®ƒæ‰€æŒ‡å‘çš„ä¸œè¥¿ï¼Œå¹¶ä¸”å½“å®ƒè¢«ä¸¢å¼ƒæ—¶ä¼šè¯•å›¾é‡Šæ”¾å®ƒæŒ‡å‘çš„å†…å­˜ã€‚å¦‚æœæˆ‘ä»¬çš„â€œpushâ€å®ç°è¢«ç¼–è¯‘äº†ï¼Œé“¾è¡¨çš„å°¾èŠ‚ç‚¹ä¼šè¢«äºŒæ¬¡é‡Šæ”¾ã€‚å®é™…ä¸Šï¼Œæˆ‘ä»¬çš„ä»£ç æ¯æ¬¡éƒ½ä¼šé‡Šæ”¾`old_tail`èŠ‚ç‚¹ã€‚

å¥½å§ï¼Œ

æˆ‘ä»¬çŸ¥é“æ€ä¹ˆåšä¸€ä¸ªéæ‹¥æœ‰çš„æŒ‡é’ˆã€‚é‚£åªæ˜¯ä¸€ä¸ªå¼•ç”¨ï¼

```rust ,ignore
pub struct List<T> {
    head: Link<T>,
    tail: Option<&mut Node<T>>, // NEW!
}

type Link<T> = Option<Box<Node<T>>>;

struct Node<T> {
    elem: T,
    next: Link<T>,
}

impl<T> List<T> {
    pub fn new() -> Self {
        List { head: None, tail: None }
    }

    pub fn push(&mut self, elem: T) {
        let new_tail = Box::new(Node {
            elem: elem,
            // When you push onto the tail, your next is always None
            next: None,
        });

        // Put the box in the right place, and then grab a reference to its Node
        let new_tail = match self.tail.take() {
            Some(old_tail) => {
                // If the old tail existed, update it to point to the new tail
                old_tail.next = Some(new_tail);
                old_tail.next.as_deref_mut()
            }
            None => {
                // Otherwise, update the head to point to it
                self.head = Some(new_tail);
                self.head.as_deref_mut()
            }
        };

        self.tail = new_tail;
    }
}
```

æ²¡ä»€ä¹ˆå¤ªæ£˜æ‰‹çš„ã€‚ä¸å‰ä¸€ä¸ªä»£ç çš„åŸºæœ¬æ€æƒ³ç›¸åŒï¼Œé™¤äº†æˆ‘ä»¬ä½¿ç”¨ä¸€äº›éšå«çš„è¿”å›æå–tailå¼•ç”¨ä»æˆ‘ä»¬è£…æ•°æ®çš„Boxã€‚

```text
> cargo build

error[E0106]: missing lifetime specifier
 --> src/fifth.rs:3:18
  |
3 |     tail: Option<&mut Node<T>>, // NEW!
  |                  ^ expected lifetime parameter
```

å“¦ï¼Œå¯¹äº†ï¼Œæˆ‘ä»¬éœ€è¦åœ¨ç±»å‹ä¸­æä¾›å‚è€ƒä¸€ç”Ÿã€‚ä»€ä¹ˆæ˜¯çš„å¼•ç”¨çš„ç”Ÿå‘½å‘¨æœŸï¼Ÿå¥½å§ï¼Œçœ‹èµ·æ¥åƒ`IterMut`ï¼Œå¯¹å§ï¼Ÿè®©æˆ‘ä»¬è¯•è¯•æˆ‘ä»¬ä¸ºIterMutæ‰€åšçš„ï¼Œåªæ·»åŠ ä¸€ä¸ªé€šç”¨çš„`'a`ï¼š

```rust ,ignore
pub struct List<'a, T> {
    head: Link<T>,
    tail: Option<&'a mut Node<T>>, // NEW!
}

type Link<T> = Option<Box<Node<T>>>;

struct Node<T> {
    elem: T,
    next: Link<T>,
}

impl<'a, T> List<'a, T> {
    pub fn new() -> Self {
        List { head: None, tail: None }
    }

    pub fn push(&mut self, elem: T) {
        let new_tail = Box::new(Node {
            elem: elem,
            // When you push onto the tail, your next is always None
            next: None,
        });

        // Put the box in the right place, and then grab a reference to its Node
        let new_tail = match self.tail.take() {
            Some(old_tail) => {
                // If the old tail existed, update it to point to the new tail
                old_tail.next = Some(new_tail);
                old_tail.next.as_deref_mut()
            }
            None => {
                // Otherwise, update the head to point to it
                self.head = Some(new_tail);
                self.head.as_deref_mut()
            }
        };

        self.tail = new_tail;
    }
}
```

```text
cargo build

error[E0495]: cannot infer an appropriate lifetime for autoref due to conflicting requirements
  --> src/fifth.rs:35:27
   |
35 |                 self.head.as_deref_mut()
   |                           ^^^^^^^^^^^^
   |
note: first, the lifetime cannot outlive the anonymous lifetime #1 defined on the method body at 18:5...
  --> src/fifth.rs:18:5
   |
18 | /     pub fn push(&mut self, elem: T) {
19 | |         let new_tail = Box::new(Node {
20 | |             elem: elem,
21 | |             // When you push onto the tail, your next is always None
...  |
39 | |         self.tail = new_tail;
40 | |     }
   | |_____^
note: ...so that reference does not outlive borrowed content
  --> src/fifth.rs:35:17
   |
35 |                 self.head.as_deref_mut()
   |                 ^^^^^^^^^
note: but, the lifetime must be valid for the lifetime 'a as defined on the impl at 13:6...
  --> src/fifth.rs:13:6
   |
13 | impl<'a, T> List<'a, T> {
   |      ^^
   = note: ...so that the expression is assignable:
           expected std::option::Option<&'a mut fifth::Node<T>>
              found std::option::Option<&mut fifth::Node<T>>


```

å“‡ï¼Œè¿™æ˜¯ä¸€ä¸ªéå¸¸è¯¦ç»†çš„é”™è¯¯ä¿¡æ¯ã€‚è¿™æœ‰ç‚¹è®©äººæ‹…å¿ƒï¼Œå› ä¸ºè¿™è¡¨æ˜æˆ‘ä»¬æ­£åœ¨åšä¸€äº›éå¸¸ç³Ÿç³•çš„äº‹æƒ…ã€‚è¿™é‡Œæœ‰ä¸€ä¸ªæœ‰è¶£çš„éƒ¨åˆ†ï¼š

> the lifetime must be valid for the lifetime `'a` as defined on the impl

æˆ‘ä»¬å€Ÿç”¨äº†`self`ï¼Œä½†ç¼–è¯‘å™¨å¸Œæœ›`self`çš„æ—¶é—´å’Œâ€œaâ€ä¸€æ ·é•¿ï¼Œå¦‚æœæˆ‘ä»¬å‘Šè¯‰å®ƒ`self`èƒ½æŒç»­é‚£ä¹ˆé•¿æ—¶é—´å‘¢ã€‚ã€‚ï¼Ÿ

```rust ,ignore
    pub fn push(&'a mut self, elem: T) {
```

```text
cargo build

warning: field is never used: `elem`
 --> src/fifth.rs:9:5
  |
9 |     elem: T,
  |     ^^^^^^^
  |
  = note: #[warn(dead_code)] on by default
```

å“¦ï¼Œå¯ä»¥äº†ï¼

è®©æˆ‘ä»¬è¯•è¯•`pop`:

```rust ,ignore
pub fn pop(&'a mut self) -> Option<T> {
    // Grab the list's current head
    self.head.take().map(|head| {
        let head = *head;
        self.head = head.next;

        // If we're out of `head`, make sure to set the tail to `None`.
        if self.head.is_none() {
            self.tail = None;
        }

        head.elem
    })
}
```

And write a quick test for that:

```rust ,ignore
mod test {
    use super::List;
    #[test]
    fn basics() {
        let mut list = List::new();

        // Check empty list behaves right
        assert_eq!(list.pop(), None);

        // Populate list
        list.push(1);
        list.push(2);
        list.push(3);

        // Check normal removal
        assert_eq!(list.pop(), Some(1));
        assert_eq!(list.pop(), Some(2));

        // Push some more just to make sure nothing's corrupted
        list.push(4);
        list.push(5);

        // Check normal removal
        assert_eq!(list.pop(), Some(3));
        assert_eq!(list.pop(), Some(4));

        // Check exhaustion
        assert_eq!(list.pop(), Some(5));
        assert_eq!(list.pop(), None);
    }
}
```

```text
cargo test

error[E0499]: cannot borrow `list` as mutable more than once at a time
  --> src/fifth.rs:68:9
   |
65 |         assert_eq!(list.pop(), None);
   |                    ---- first mutable borrow occurs here
...
68 |         list.push(1);
   |         ^^^^
   |         |
   |         second mutable borrow occurs here
   |         first borrow later used here

error[E0499]: cannot borrow `list` as mutable more than once at a time
  --> src/fifth.rs:69:9
   |
65 |         assert_eq!(list.pop(), None);
   |                    ---- first mutable borrow occurs here
...
69 |         list.push(2);
   |         ^^^^
   |         |
   |         second mutable borrow occurs here
   |         first borrow later used here

error[E0499]: cannot borrow `list` as mutable more than once at a time
  --> src/fifth.rs:70:9
   |
65 |         assert_eq!(list.pop(), None);
   |                    ---- first mutable borrow occurs here
...
70 |         list.push(3);
   |         ^^^^
   |         |
   |         second mutable borrow occurs here
   |         first borrow later used here


....

** WAY MORE LINES OF ERRORS **

....

error: aborting due to 11 previous errors
```

ğŸ™€ğŸ™€ğŸ™€ğŸ™€ğŸ™€ğŸ™€ğŸ™€ğŸ™€ğŸ™€ğŸ™€ğŸ™€ğŸ™€ğŸ™€ğŸ™€ğŸ™€ğŸ™€ğŸ™€ğŸ™€ğŸ™€ğŸ™€ğŸ™€ğŸ™€ğŸ™€

Oh my goodness.

The compiler's not wrong for vomiting all over us. We just committed a
cardinal Rust sin: we stored a reference to ourselves *inside ourselves*.
Somehow, we managed to convince Rust that this totally made sense in our
`push` and `pop` implementations (I was legitimately shocked we did). I believe
the reason is that Rust can't yet tell that the reference is into ourselves
from just `push` and `pop` -- or rather, Rust doesn't really have that notion
at all. Reference-into-yourself failing to work is just an emergent behaviour.

As soon as we tried to *use* our list, everything quickly fell apart.
When we call `push` or `pop`, we promptly store a reference to ourselves in
ourselves and become *trapped*. We are literally borrowing ourselves.

Our `pop` implementation hints at why this could be really dangerous:

```rust ,ignore
// ...
if self.head.is_none() {
    self.tail = None;
}
```

What if we forgot to do this? Then our tail would point to some node *that
had been removed from the list*. Such a node would be instantly freed, and we'd
have a dangling pointer which Rust was supposed to protect us from!

And indeed Rust is protecting us from that kind of danger. Just in a very...
**roundabout** way.

æˆ‘ä»¬æ€ä¹ˆåŠ? å›åˆ°Rc<RefCell>>` ?

Please. No.

ä¸ï¼Œç›¸åï¼Œæˆ‘ä»¬å°†è¶Šè½¨å¹¶ä½¿ç”¨`è£¸æŒ‡é’ˆ`ã€‚ æˆ‘ä»¬çš„å¸ƒå±€å°†å¦‚ä¸‹æ‰€ç¤ºï¼š

```rust ,ignore
pub struct List<T> {
    head: Link<T>,
    tail: *mut Node<T>, // DANGER DANGER
}

type Link<T> = Option<Box<Node<T>>>;

struct Node<T> {
    elem: T,
    next: Link<T>,
}
```

å°±è¿™æ ·ï¼Œæ²¡æœ‰å¼•ç”¨è®¡æ•°åŠ¨æ€å€Ÿç”¨æ£€æŸ¥ä¹‹ç±»çš„èƒ¡æ‰¯ï¼Œåªæœ‰éš¾åº¦æé«˜çš„æœªæ£€æŸ¥æŒ‡é’ˆã€‚

è®©æˆ‘ä»¬éƒ½å˜ä¸ºCï¼Œè¿™ä¸€å¤©å…¨æ˜¯Cã€‚

æˆ‘å›æ¥äº† ï¼Œæˆ‘å‡†å¤‡å¥½äº†ã€‚

ä½ å¥½ `unsafe`.