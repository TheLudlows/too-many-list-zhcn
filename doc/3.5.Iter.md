# Iter

å¥½å§ï¼Œæˆ‘ä»¬å°è¯•å®ç°Iterï¼Œè¿™æ¬¡æˆ‘ä»¬æ— æ³•ä¾é Listæä¾›çš„åŠŸèƒ½æ¥å®ç°ã€‚éœ€è¦è‡ªå·±åŠ¨æ‰‹äº†ï¼Œæˆ‘ä»¬çš„åŸºæœ¬æ€è·¯æ˜¯æŒæœ‰ä¸€ä¸ªæŒ‡å‘å½“å‰çš„èŠ‚ç‚¹çš„æŒ‡é’ˆï¼Œè¿™ä¸ªèŠ‚ç‚¹åœ¨ä¸‹æ¬¡nextæ–¹æ³•è¿”å›ã€‚å› ä¸ºèŠ‚ç‚¹å¯èƒ½ä¸ºç©ºï¼Œå› æ­¤æˆ‘ä»¬å°†å¼•ç”¨åŒ…åœ¨Optionä¸­ã€‚å½“äº§ç”Ÿä¸€ä¸ªå…ƒç´ ï¼Œæˆ‘ä»¬æŠŠå½“å½“å‰å…ƒç´ çŸ¥é“ä¸‹ä¸€ä¸ªå…ƒç´ ã€‚

å¥½ï¼ï¼Œæ¥è¯•è¯•

```rust ,ignore
pub struct Iter<T> {
    next: Option<&Node<T>>,
}

impl<T> List<T> {
    pub fn iter(&self) -> Iter<T> {
        Iter { next: self.head.map(|node| &node) }
    }
}

impl<T> Iterator for Iter<T> {
    type Item = &T;

    fn next(&mut self) -> Option<Self::Item> {
        self.next.map(|node| {
            self.next = node.next.map(|node| &node);
            &node.elem
        })
    }
}
```

```text
> cargo build

error[E0106]: missing lifetime specifier
  --> src/second.rs:72:18
   |
72 |     next: Option<&Node<T>>,
   |                  ^ expected lifetime parameter

error[E0106]: missing lifetime specifier
  --> src/second.rs:82:17
   |
82 |     type Item = &T;
   |                 ^ expected lifetime parameter
```

å¤©å‘. å£°æ˜å‘¨æœŸ. æˆ‘å¬è¯´è¿‡è¿™äº›ä¸œè¥¿ï¼Œè¿™ç®€ç›´æ˜¯å™©æ¢¦ã€‚

è®©æˆ‘ä»¬å°è¯•ä¸€äº›æ–°çš„ä¸œè¥¿ï¼šçœ‹åˆ°`errr[E0106]`äº†å—ï¼Ÿé‚£æ˜¯ç¼–è¯‘å™¨é”™è¯¯ç ï¼Œæˆ‘ä»¬è®©rustcæ¥è§£é‡Šï¼Œå¥½ï¼Œ`--explain`:

```text
> rustc --explain E0106
This error indicates that a lifetime is missing from a type. If it is an error
inside a function signature, the problem may be with failing to adhere to the
lifetime elision rules (see below).

Here are some simple examples of where you'll run into this error:

struct Foo { x: &bool }        // error
struct Foo<'a> { x: &'a bool } // correct

enum Bar { A(u8), B(&bool), }        // error
enum Bar<'a> { A(u8), B(&'a bool), } // correct

type MyStr = &str;        // error
type MyStr<'a> = &'a str; //correct
...
```

å—¯...å¹¶æ²¡æœ‰çœŸæ­£å¼„æ¸…æ¥šï¼ˆæ–‡æ¡£å‡è®¾æˆ‘ä»¬ç°åœ¨æ›´äº†è§£Rustäº†ï¼‰ã€‚ä½†æ˜¯çœ‹èµ·æ¥æˆ‘ä»¬åº”è¯¥åŠ ä¸€äº›``a`åˆ°æˆ‘ä»¬çš„ç»“æ„ä½“ã€‚è¯•è¯•çœ‹ã€‚

```
pub struct Iter<'a, T> {
    next: Option<&'a Node<T>>,
}
```

```text
> cargo build

error[E0106]: missing lifetime specifier
  --> src/second.rs:83:22
   |
83 | impl<T> Iterator for Iter<T> {
   |                      ^^^^^^^ expected lifetime parameter

error[E0106]: missing lifetime specifier
  --> src/second.rs:84:17
   |
84 |     type Item = &T;
   |                 ^ expected lifetime parameter

error: aborting due to 2 previous errors
```

å¥½ï¼Œæˆ‘è¿™é‡Œçœ‹åˆ°äº†ä¸€ç§æ¨¡å¼...æˆ‘ä»¬æŠŠèƒ½åŠ çš„åœ°æ–¹æ³•éƒ½åŠ ä¸Šè¿™äº›å°å®¶ä¼™ã€‚

```rust ,ignore
pub struct Iter<'a, T> {
    next: Option<&'a Node<T>>,
}

impl<'a, T> List<T> {
    pub fn iter(&'a self) -> Iter<'a, T> {
        Iter { next: self.head.map(|node| &'a node) }
    }
}

impl<'a, T> Iterator for Iter<'a, T> {
    type Item = &'a T;
    fn next(&'a mut self) -> Option<Self::Item> {
        self.next.map(|node| {
            self.next = node.next.map(|node| &'a node);
            &'a node.elem
        })
    }
}
```

```text
> cargo build

error: expected `:`, found `node`
  --> src/second.rs:77:47
   |
77 |         Iter { next: self.head.map(|node| &'a node) }
   |         ---- while parsing this struct        ^^^^ expected `:`

error: expected `:`, found `node`
  --> src/second.rs:85:50
   |
85 |             self.next = node.next.map(|node| &'a node);
   |                                                  ^^^^ expected `:`

error[E0063]: missing field `next` in initializer of `second::Iter<'_, _>`
  --> src/second.rs:77:9
   |
77 |         Iter { next: self.head.map(|node| &'a node) }
   |         ^^^^ missing `next`
```

å¤©å‘ï¼æˆ‘ä»¬ç ´åäº†Rustã€‚

æˆ–è®¸æˆ‘ä»¬åº”è¯¥çœŸæ­£çš„ææ¸…æ¥š`lifetime`æ„å‘³ç€ä»€ä¹ˆã€‚

ç”Ÿå‘½å‘¨æœŸå¯èƒ½ä¼šå“è·‘å¾ˆå¤šäººï¼Œå› ä¸ºå®ƒä»¬æ”¹å˜äº†æˆ‘ä»¬ä»ç¼–ç¨‹ä¹‹åˆå°±çŸ¥é“å¹¶å–œæ¬¢çš„ä¸œè¥¿ã€‚åˆ°ç›®å‰ä¸ºæ­¢ï¼Œæˆ‘ä»¬å·²ç»æˆåŠŸèº²è¿‡äº†lifetimeï¼Œå°½ç®¡å®ƒä¸€ç›´åœ¨æ‰°ä¹±æˆ‘ä»¬çš„ç¨‹åºã€‚

åœ¨åƒåœ¾æ”¶é›†çš„è¯­è¨€ä¸­ç”Ÿå‘½å‘¨æœŸæ˜¯ä¸å¿…è¦çš„ï¼Œå› ä¸ºåƒåœ¾æ”¶é›†å™¨ç¡®ä¿æ‰€æœ‰ä¸œè¥¿éƒ½èƒ½ç¥å¥‡åœ°å­˜åœ¨ï¼Œåªè¦å®ƒéœ€è¦ã€‚Rustä¸­çš„å¤§å¤šæ•°æ•°æ®éƒ½æ˜¯æ‰‹åŠ¨ç®¡ç†çš„ï¼Œå› æ­¤æ•°æ®éœ€è¦å¦ä¸€ç§è§£å†³æ–¹æ¡ˆã€‚Cå’ŒC++ç»™å‡ºäº†ä¸€ä¸ªæ˜ç¡®çš„ä¾‹å­ï¼Œå¦‚æœä½ åªæ˜¯è®©äººä»¬ç”¨æŒ‡é’ˆå¯ä»¥æŒ‡å‘ä»»æ„çš„æ•°æ®ï¼ŒåŸºæœ¬ä¸Šæ˜¯ä¸å¯ç®¡ç†å’Œä¸å®‰å…¨çš„ã€‚

è¿™å¯ä»¥å¤§è‡´åˆ†ä¸ºä¸¤ç±»é”™è¯¯ï¼š

- æŒæœ‰è¶…å‡ºä½œç”¨åŸŸçš„æŒ‡é’ˆ
- æŒæœ‰å·²ç»å˜åŒ–çš„æŒ‡é’ˆ

ç”Ÿå‘½å‘¨æœŸä»¥æ˜¾ç¤ºæ–¹å¼è§£å†³äº†è¿™ä¸¤ç§é—®é¢˜99%çš„æƒ…å†µï¼Œ

æ‰€ä»¥ä»€ä¹ˆæ˜¯ç”Ÿå‘½å‘¨æœŸï¼Ÿ

ç›¸å½“ç®€å•ï¼Œç”Ÿå‘½å‘¨æœŸæ˜¯ç¨‹åºä¸­æŸä¸ªä»£ç åŒºåŸŸçš„åç§°ã€‚å°±æ˜¯å½“ä¸€ä¸ª å¼•ç”¨è¢«ç”Ÿå‘½å‘¨æœŸæ ‡è®°ï¼Œæˆ‘ä»¬å°±è¯´å®ƒåœ¨æ•´ä¸ªåŒºåŸŸä¸­ ä¸€å®šæœ‰æ•ˆã€‚ä¸åŒçš„æƒ…å†µå¯¹å¼•ç”¨çš„æœ‰æ•ˆæœŸè¦æ±‚ä¸åŒã€‚æ•´ä¸ªç”Ÿå‘½å‘¨æœŸç³»ç»Ÿåˆæ˜¯ä¸€ä¸ªçº¦æŸæ±‚è§£ç³»ç»Ÿï¼ˆconstraint-solving system ï¼‰ï¼Œå®ƒè¯•å›¾æœ€å°åŒ–æ¯ä¸ªå¼•ç”¨çš„åŒºåŸŸã€‚å¦‚æœå®ƒæˆåŠŸåœ°æ‰¾åˆ°äº†ä¸€ç»„æ»¡è¶³æ‰€æœ‰çº¦æŸçš„ç”Ÿå‘½å‘¨æœŸï¼Œé‚£ä¹ˆä½ çš„ç¨‹åºå°±å¯ä»¥ç¼–è¯‘äº†ï¼å¦åˆ™ä½ ä¼šå¾—åˆ°ä¸€ä¸ªé”™è¯¯ï¼Œè¯´æœ‰äº›ä¸œè¥¿æ´»å¾—ä¸å¤Ÿé•¿ã€‚

åœ¨ä¸€ä¸ªæ–¹æ³•ä½“ä¸­ä¸€èˆ¬ä¸è°ˆè®ºç”Ÿå‘½å‘¨æœŸï¼Œå½“ç„¶æˆ‘ä»¬ä¹Ÿä¸æƒ³è°ˆã€‚ç¼–è¯‘å™¨ç”¨å®Œæ•´çš„ä¿¡æ¯å¯ä»¥æ¨æ–­å‡ºæ‰€æœ‰çš„çº¦æŸæ¥æ‰¾åˆ°æ‰€éœ€æœ€å°çš„ç”Ÿå‘½å‘¨æœŸã€‚ä½†æ˜¯åœ¨ç±»å‹å’ŒAPIçº§åˆ«ï¼Œç¼–è¯‘å™¨å¹¶æ²¡æœ‰æ‰€æœ‰çš„ä¿¡æ¯ã€‚å®ƒéœ€è¦ä½ å‘Šè¯‰å®ƒå…³äºä¸åŒç”Ÿå‘½å‘¨æœŸä¹‹é—´çš„å…³ç³»ï¼Œè¿™æ ·å®ƒå°±èƒ½çŸ¥é“ä½ åœ¨åšä»€ä¹ˆã€‚

åŸåˆ™ä¸Šï¼Œè¿™äº›ç”Ÿå‘½å‘¨æœŸä¹Ÿå¯ä»¥è¢«å¿½ç•¥ï¼Œä½†æ˜¯æ£€æŸ¥æ‰€æœ‰çš„å€Ÿç”¨å°†ä¼šæ˜¯ä¸€ä¸ªåºå¤§çš„å…¨ç¨‹åºåˆ†æï¼Œè¿™å¯èƒ½äº§ç”Ÿä»¤äººéš¾ä»¥ç½®ä¿¡çš„éå±€éƒ¨é”™è¯¯ã€‚Rustç³»ç»Ÿå°†æ‰€æœ‰çš„å€Ÿç”¨æ£€æŸ¥åœ¨æ¯ä¸ªæ–¹æ³•ä½“ä¸­ç‹¬ç«‹å®Œæˆã€‚ä½ æ‰€æœ‰çš„é”™è¯¯éƒ½åº”è¯¥æ˜¯å±€éƒ¨çš„ï¼ˆæˆ–è€…ç±»å‹çš„ç­¾åä¸æ­£ç¡®ï¼‰ã€‚

ä½†æˆ‘ä»¬ä»¥å‰å†™è¿‡å‡½æ•°çš„å¼•ç”¨ç­¾åï¼Œä¸€åˆ‡éƒ½æ²¡é—®é¢˜ï¼é‚£æ˜¯å› ä¸ºæœ‰äº›æƒ…å†µéå¸¸æ™®éï¼ŒRustä¼šè‡ªåŠ¨ä¸ºä½ é€‰æ‹©ç”Ÿå‘½å‘¨æœŸã€‚è¿™å°±æ˜¯ç”Ÿå‘½å‘¨æœŸçœç•¥ã€‚

å°¤å…¶æ˜¯:

```rust ,ignore
// Only one reference in input, so the output must be derived from that input
fn foo(&A) -> &B; // sugar for:
fn foo<'a>(&'a A) -> &'a B;

// Many inputs, assume they're all independent
fn foo(&A, &B, &C); // sugar for:
fn foo<'a, 'b, 'c>(&'a A, &'b B, &'c C);

// Methods, assume all output lifetimes are derived from `self`
fn foo(&self, &B, &C) -> &D; // sugar for:
fn foo<'a, 'b, 'c>(&'a self, &'b B, &'c C) -> &'a D;
```

é‚£ä¹ˆ `fn foo<'a>(&'a A) -> &'a B` æ˜¯ä»€ä¹ˆæ„æ€ï¼Ÿå®é™…ä¸Šè¿™æ„å‘³ç€è¾“å…¥çš„å¯¿å‘½å¿…é¡»è‡³å°‘å’Œè¾“å‡ºçš„å¯¿å‘½ä¸€æ ·é•¿ã€‚å› æ­¤å¦‚æœé•¿æ—¶é—´ä¿æŒè¾“å‡ºï¼Œåˆ™éœ€è¦æ‰©å±•è¾“å…¥çš„çš„æœ‰æ•ˆèŒƒå›´ï¼Œä¸€æ—¦ä½ ä¸å†ä½¿ç”¨è¾“å‡ºï¼Œç¼–è¯‘å™¨å°±ä¼šçŸ¥é“è¾“å…¥ä¹Ÿå¯ä»¥å˜ä¸ºæ— æ•ˆã€‚

æœ‰äº†è¿™ä¸ªç³»ç»Ÿï¼ŒRustå¯ä»¥ä¿è¯ä¸åœ¨ä½¿ç”¨é‡Šæ”¾ä¹‹åçš„ä¸œè¥¿ï¼ŒåŒæ—¶å­˜åœ¨å¼•ç”¨æ—¶ï¼Œä¸ä¼šæ”¹å˜ä»»ä½•ä¸œè¥¿ã€‚å®ƒåªæ˜¯ç¡®ä¿æ‰€æœ‰çš„çº¦æŸéƒ½èƒ½è§£å†³ï¼

å¥½å§ï¼Œæ‰€ä»¥ï¼ŒIterã€‚

è®©æˆ‘ä»¬å›é€€åˆ°æ— ç”Ÿå‘½å‘¨æœŸçš„çŠ¶æ€ï¼š

```rust ,ignore
pub struct Iter<T> {
    next: Option<&Node<T>>,
}

impl<T> List<T> {
    pub fn iter(&self) -> Iter<T> {
        Iter { next: self.head.map(|node| &node) }
    }
}

impl<T> Iterator for Iter<T> {
    type Item = &T;
    fn next(&mut self) -> Option<Self::Item> {
        self.next.map(|node| {
            self.next = node.next.map(|node| &node);
            &node.elem
        })
    }
}
```

æˆ‘ä»¬åªéœ€è¦åœ¨å‡½æ•°å’Œç±»å‹ç­¾åä¸­æ·»åŠ ç”Ÿå‘½å‘¨æœŸï¼š

```rust ,ignore
// Iter is generic over *some* lifetime, it doesn't care
pub struct Iter<'a, T> {
    next: Option<&'a Node<T>>,
}

// No lifetime here, List doesn't have any associated lifetimes
impl<T> List<T> {
    // We declare a fresh lifetime here for the *exact* borrow that
    // creates the iter. Now &self needs to be valid as long as the
    // Iter is around.
    pub fn iter<'a>(&'a self) -> Iter<'a, T> {
        Iter { next: self.head.map(|node| &node) }
    }
}

// We *do* have a lifetime here, because Iter has one that we need to define
impl<'a, T> Iterator for Iter<'a, T> {
    // Need it here too, this is a type declaration
    type Item = &'a T;

    // None of this needs to change, handled by the above.
    // Self continues to be incredibly hype and amazing
    fn next(&mut self) -> Option<Self::Item> {
        self.next.map(|node| {
            self.next = node.next.map(|node| &node);
            &node.elem
        })
    }
}
```

å¥½å§ï¼Œæˆ‘æƒ³è¿™æ¬¡æˆ‘ä»¬èƒ½æå®šäº†,

```text
cargo build

error[E0308]: mismatched types
  --> src/second.rs:77:22
   |
77 |         Iter { next: self.head.map(|node| &node) }
   |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct `second::Node`, found struct `std::boxed::Box`
   |
   = note: expected type `std::option::Option<&second::Node<T>>`
              found type `std::option::Option<&std::boxed::Box<second::Node<T>>>`

error[E0308]: mismatched types
  --> src/second.rs:85:25
   |
85 |             self.next = node.next.map(|node| &node);
   |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct `second::Node`, found struct `std::boxed::Box`
   |
   = note: expected type `std::option::Option<&'a second::Node<T>>`
              found type `std::option::Option<&std::boxed::Box<second::Node<T>>>`
```

(â•¯Â°â–¡Â°)â•¯ï¸µ â”»â”â”»

å¥½æŠŠï¼Œæˆ‘ä»¬ä¿®å¤äº†ç”Ÿå‘½å‘¨æœŸä¸­çš„é”™è¯¯ï¼Œä½†æ˜¯ç°åœ¨æˆ‘ä»¬å¾—åˆ°äº†ä¸€äº›æ–°é”™è¯¯ã€‚æˆ‘ä»¬æƒ³è·å–`&Node`ï¼Œä½†æ˜¯å¾—åˆ°äº†`&Box<Node>`ï¼Œè¿™å¾ˆç®€å•ï¼Œæˆ‘ä»¬åªéœ€è¦å¯¹Boxè§£å¼•ç”¨ï¼Œå†æ‹¿åˆ°å€¼å¾—å¼•ç”¨ã€‚

```rust ,ignore
impl<T> List<T> {
    pub fn iter<'a>(&'a self) -> Iter<'a, T> {
        Iter { next: self.head.map(|node| &*node) }
    }
}

impl<'a, T> Iterator for Iter<'a, T> {
    type Item = &'a T;
    fn next(&mut self) -> Option<Self::Item> {
        self.next.map(|node| {
            self.next = node.next.map(|node| &*node);
            &node.elem
        })
    }
}
```

```text
cargo build
   Compiling lists v0.1.0 (/Users/ABeingessner/dev/temp/lists)
error[E0515]: cannot return reference to local data `*node`
  --> src/second.rs:77:43
   |
77 |         Iter { next: self.head.map(|node| &*node) }
   |                                           ^^^^^^ returns a reference to data owned by the current function

error[E0507]: cannot move out of borrowed content
  --> src/second.rs:77:22
   |
77 |         Iter { next: self.head.map(|node| &*node) }
   |                      ^^^^^^^^^ cannot move out of borrowed content

error[E0515]: cannot return reference to local data `*node`
  --> src/second.rs:85:46
   |
85 |             self.next = node.next.map(|node| &*node);
   |                                              ^^^^^^ returns a reference to data owned by the current function

error[E0507]: cannot move out of borrowed content
  --> src/second.rs:85:25
   |
85 |             self.next = node.next.map(|node| &*node);
   |                         ^^^^^^^^^ cannot move out of borrowed content
```

(ï¾‰à²¥ç›Šà²¥ï¼‰ï¾‰ï»¿ â”»â”â”»

å¿˜äº†`as_ref`ï¼Œæˆ‘ä»¬æŠŠBoxç§»åŠ¨å¦‚mapä¸­çš„ï¼Œè¿™æ„å‘³ç€Boxä¼šä¸¢å¼ƒï¼Œæˆ‘ä»¬è¿”å›çš„å¼•ç”¨å°†ä¼šå‚æ‚¬ã€‚

```rust ,ignore
pub struct Iter<'a, T> {
    next: Option<&'a Node<T>>,
}

impl<T> List<T> {
    pub fn iter<'a>(&'a self) -> Iter<'a, T> {
        Iter { next: self.head.as_ref().map(|node| &*node) }
    }
}

impl<'a, T> Iterator for Iter<'a, T> {
    type Item = &'a T;

    fn next(&mut self) -> Option<Self::Item> {
        self.next.map(|node| {
            self.next = node.next.as_ref().map(|node| &*node);
            &node.elem
        })
    }
}
```

```text
cargo build
   Compiling lists v0.1.0 (/Users/ABeingessner/dev/temp/lists)
error[E0308]: mismatched types
  --> src/second.rs:77:22
   |
77 |         Iter { next: self.head.as_ref().map(|node| &*node) }
   |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct `second::Node`, found struct `std::boxed::Box`
   |
   = note: expected type `std::option::Option<&second::Node<T>>`
              found type `std::option::Option<&std::boxed::Box<second::Node<T>>>`

error[E0308]: mismatched types
  --> src/second.rs:85:25
   |
85 |             self.next = node.next.as_ref().map(|node| &*node);
   |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct `second::Node`, found struct `std::boxed::Box`
   |
   = note: expected type `std::option::Option<&'a second::Node<T>>`
              found type `std::option::Option<&std::boxed::Box<second::Node<T>>>`

```

ğŸ˜­

`as_ref` åˆå¢åŠ äº†ä¸€å±‚å¼•ç”¨ï¼Œéœ€è¦å»æ‰


```rust ,ignore
pub struct Iter<'a, T> {
    next: Option<&'a Node<T>>,
}

impl<T> List<T> {
    pub fn iter<'a>(&'a self) -> Iter<'a, T> {
        Iter { next: self.head.as_deref() }
    }
}

impl<'a, T> Iterator for Iter<'a, T> {
    type Item = &'a T;

    fn next(&mut self) -> Option<Self::Item> {
        self.next.map(|node| {
            self.next = node.next.as_deref();
            &node.elem
        })
    }
}
```

```text
cargo build

```

ğŸ‰ ğŸ‰ ğŸ‰

 as_deref å’Œ as-derf_muå‡½æ•°åœ¨1.40ç‰ˆæœ¬ç¨³å®šä¸‹æ¥ï¼Œå†æ­¤ä¹‹å‰ä½ éœ€è¦ä½¿ç”¨`map(|node| &**node)` æˆ–`map(|node| &mut **node)`ã€‚ä½ å¯èƒ½ä¼šè®¤ä¸º `&**`ä¹Ÿå¤ªä¸‘äº†æŠŠï¼Œæ²¡é”™ï¼å°±åƒé…’ä¸€æ ·ï¼ŒRustä¼šéšç€æ—¶é—´çš„æ¨ç§»å˜å¾—æ›´å¥½ï¼Œæˆ‘ä»¬ä¸å†éœ€è¦åƒä¹‹å‰é‚£æ ·åšäº†ã€‚é€šå¸¸Rustå¾ˆæ“…é•¿éšå¼åœ°è¿›è¡Œè¿™ç§è½¬æ¢ï¼Œé€šè¿‡ä¸€ä¸ªå«derefå°±å¯ä»¥åœ¨ä»£ç ä¸­æ’å…¥*ï¼Œä¸”èƒ½é€šè¿‡ç±»å‹æ£€æŸ¥ã€‚å®ƒèƒ½åšåˆ°è¿™ä¸€ç‚¹ï¼Œæ˜¯å› ä¸ºæˆ‘ä»¬æœ‰å€Ÿç”¨æ£€æŸ¥å™¨ï¼Œä»¥ç¡®ä¿æˆ‘ä»¬æ°¸è¿œä¸ä¼šå¼„ä¹±æŒ‡é’ˆï¼

åœ¨æœ¬ä¾‹ä¸­ï¼Œæˆ‘ä»¬ä½¿ç”¨äº†Option<&T>è€Œä¸æ˜¯&Tï¼Œå› ä¸ºå‰è€…å¤ªå¤æ‚äº†ã€‚æ‰€ä»¥æˆ‘ä»¬éœ€è¦é€šè¿‡æ˜ç¡®çš„æ–¹å¼æ¥å¸®åŠ©å®ƒã€‚è°¢å¤©è°¢åœ°ï¼Œä»¥æˆ‘çš„ç»éªŒï¼Œè¿™æ˜¯ç›¸å½“ç½•è§çš„ã€‚
ä¸ºäº†å®Œæ•´èµ·è§ï¼Œæˆ‘ä»¬å¯ä»¥ç”¨*turbofish*

```rust ,ignore
self.next = node.next.as_ref().map::<&Node<T>, _>(|node| &node);
```

è¯·çœ‹ï¼Œmapæ˜¯ä¸€ä¸ªæ³›å‹å‡½æ•°ï¼š

```rust ,ignore
pub fn map<U, F>(self, f: F) -> Option<U>
```

turbofish`ï¼šï¼š<>`è®©æˆ‘ä»¬å‘Šè¯‰ç¼–è¯‘å™¨æ³›å‹åº”è¯¥æ˜¯ä»€ä¹ˆç±»å‹ï¼Œåœ¨æœ¬ä¾‹ä¸­ï¼Œ`ï¼šï¼š<&Node<T>ï¼Œ>`è¡¨ç¤ºå®ƒåº”è¯¥è¿”å›ä¸€ä¸ª

`&Node<T>`ï¼Œæˆ‘ä¸å…³å¿ƒå¦å…¶ä»–ç±»å‹ã€‚

è¿™åˆè®©ç¼–è¯‘å™¨çŸ¥é“`&node`åº”è¯¥å¯ç”¨äºå¼ºåˆ¶derefï¼Œæ‰€ä»¥æˆ‘ä»¬ä¸éœ€è¦æ‰‹åŠ¨*ï¼

ä½†åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œæˆ‘ä¸è®¤ä¸ºè¿™çœŸçš„æ˜¯ä¸€ç§è¿›æ­¥ï¼Œè¿™åªæ˜¯ä¸€ä¸ªå±•ç¤ºä½¿ç”¨turbofishæ˜¯ä¸€ä¸ªæœ‰ç”¨çš„æ¥å£ğŸ˜…

è®©æˆ‘ä»¬å†™ä¸€ä¸ªæµ‹è¯•æ¥ç¡®å®šæˆ‘ä»¬æ²¡ç ´åå®ƒï¼š

```rust ,ignore
#[test]
fn iter() {
    let mut list = List::new();
    list.push(1); list.push(2); list.push(3);

    let mut iter = list.iter();
    assert_eq!(iter.next(), Some(&3));
    assert_eq!(iter.next(), Some(&2));
    assert_eq!(iter.next(), Some(&1));
}
```

```text
> cargo test

     Running target/debug/lists-5c71138492ad4b4a

running 5 tests
test first::test::basics ... ok
test second::test::basics ... ok
test second::test::into_iter ... ok
test second::test::iter ... ok
test second::test::peek ... ok

test result: ok. 4 passed; 0 failed; 0 ignored; 0 measured

```

æœ€åï¼Œéœ€è¦æ³¨æ„çš„æ˜¯ï¼Œæˆ‘ä»¬*å¯ä»¥*åœ¨è¿™é‡Œè¿›è¡Œç”Ÿå‘½å‘¨æœŸå‚æ•°çœç•¥ã€‚

```rust ,ignore
impl<T> List<T> {
    pub fn iter<'a>(&'a self) -> Iter<'a, T> {
        Iter { next: self.head.as_deref() }
    }
}
```

ç›¸å½“äº

```rust ,ignore
impl<T> List<T> {
    pub fn iter(&self) -> Iter<T> {
        Iter { next: self.head.as_deref() }
    }
}
```

å¾ˆå°‘çš„ç”Ÿå‘½å‘¨æœŸå‚æ•°

æˆ–è€…ï¼Œå¦‚æœä½ ä¸æ„¿æ„â€œéšè—â€ä¸€ä¸ªç»“æ„åŒ…å«ä¸€ä¸ªç”Ÿå‘½å‘¨æœŸï¼Œæ‚¨å¯ä»¥ä½¿ç”¨Rust2018æ˜¾å¼çœç•¥ç”Ÿå­˜æœŸè¯­æ³•`'_`

```rust ,ignore
impl<T> List<T> {
    pub fn iter(&self) -> Iter<'_, T> {
        Iter { next: self.head.as_deref() }
    }
}
```